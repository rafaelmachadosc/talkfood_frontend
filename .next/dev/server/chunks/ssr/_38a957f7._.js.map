{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Rafael%20Machado/Downloads/Frontend/src/core/config/environment-strategy.ts"],"sourcesContent":["/**\n * Strategy Pattern para gerenciar diferentes ambientes de conexão\n * Suporta: Local, Cloudflare Tunnel, e outros ambientes customizados\n */\n\nexport enum EnvironmentType {\n  LOCAL = \"local\",\n  CLOUDFLARE_TUNNEL = \"cloudflare\",\n  PRODUCTION = \"production\",\n  DEVELOPMENT = \"development\",\n}\n\nexport interface EnvironmentConfig {\n  readonly type: EnvironmentType;\n  readonly frontendPort: number;\n  readonly backendPort: number;\n  readonly baseUrl: string;\n  readonly protocol: \"http\" | \"https\";\n  readonly hostname: string;\n  readonly apiPath: string;\n}\n\n/**\n * Strategy Interface para diferentes configurações de ambiente\n */\nexport interface IEnvironmentStrategy {\n  getConfig(): EnvironmentConfig;\n  getApiBaseUrl(): string;\n  isSecure(): boolean;\n}\n\n/**\n * Strategy para ambiente Local\n */\nexport class LocalEnvironmentStrategy implements IEnvironmentStrategy {\n  private readonly config: EnvironmentConfig;\n\n  constructor() {\n    this.config = {\n      type: EnvironmentType.LOCAL,\n      frontendPort: 3000,\n      backendPort: 8081,\n      protocol: \"http\",\n      hostname: \"localhost\",\n      apiPath: \"\",\n      baseUrl: \"http://localhost:8081\",\n    };\n  }\n\n  getConfig(): EnvironmentConfig {\n    return this.config;\n  }\n\n  getApiBaseUrl(): string {\n    return this.config.baseUrl;\n  }\n\n  isSecure(): boolean {\n    return false;\n  }\n}\n\n/**\n * Strategy para Cloudflare Tunnel\n */\nexport class CloudflareTunnelStrategy implements IEnvironmentStrategy {\n  private readonly config: EnvironmentConfig;\n\n  constructor(tunnelUrl?: string) {\n    // Prioridade: parâmetro > variável de ambiente > domínio padrão\n    let tunnelHost = tunnelUrl?.trim() || \n                     process.env.NEXT_PUBLIC_CLOUDFLARE_TUNNEL_URL?.trim() || \n                     \"https://talkfoodsoftwerk.net\";\n    \n    // Garantir que sempre temos uma URL válida (fallback de segurança)\n    if (!tunnelHost || tunnelHost === \"\") {\n      tunnelHost = \"https://talkfoodsoftwerk.net\";\n    }\n    \n    this.config = {\n      type: EnvironmentType.CLOUDFLARE_TUNNEL,\n      frontendPort: 3000,\n      backendPort: 8081,\n      protocol: \"https\",\n      hostname: this.extractHostname(tunnelHost),\n      apiPath: \"\",\n      baseUrl: tunnelHost,\n    };\n  }\n\n  private extractHostname(url: string): string {\n    try {\n      const urlObj = new URL(url);\n      return urlObj.hostname;\n    } catch {\n      return \"localhost\";\n    }\n  }\n\n  getConfig(): EnvironmentConfig {\n    return this.config;\n  }\n\n  getApiBaseUrl(): string {\n    return this.config.baseUrl;\n  }\n\n  isSecure(): boolean {\n    return true;\n  }\n}\n\n/**\n * Strategy para ambiente de Produção\n */\nexport class ProductionEnvironmentStrategy implements IEnvironmentStrategy {\n  private readonly config: EnvironmentConfig;\n\n  constructor(productionUrl?: string) {\n    const prodUrl = productionUrl || process.env.NEXT_PUBLIC_API_URL || \"https://talkfoodsoftwerk.net\";\n    \n    // Garantir que sempre temos uma URL válida\n    const validUrl = prodUrl || \"https://talkfoodsoftwerk.net\";\n    \n    this.config = {\n      type: EnvironmentType.PRODUCTION,\n      frontendPort: 443,\n      backendPort: 443,\n      protocol: \"https\",\n      hostname: this.extractHostname(validUrl),\n      apiPath: \"\",\n      baseUrl: validUrl,\n    };\n  }\n\n  private extractHostname(url: string): string {\n    try {\n      const urlObj = new URL(url);\n      return urlObj.hostname;\n    } catch {\n      return \"localhost\";\n    }\n  }\n\n  getConfig(): EnvironmentConfig {\n    return this.config;\n  }\n\n  getApiBaseUrl(): string {\n    return this.config.baseUrl;\n  }\n\n  isSecure(): boolean {\n    return true;\n  }\n}\n\n/**\n * Factory para criar a estratégia de ambiente apropriada\n */\nexport class EnvironmentStrategyFactory {\n  static create(): IEnvironmentStrategy {\n    const envType = process.env.NEXT_PUBLIC_ENVIRONMENT_TYPE || \n                   process.env.NODE_ENV || \n                   \"local\";\n\n    const isProduction = envType.toLowerCase() === \"production\" || \n                        process.env.NODE_ENV === \"production\";\n\n    // Prioridade 1: Se NEXT_PUBLIC_API_URL está configurado, usar ProductionStrategy\n    const apiUrl = process.env.NEXT_PUBLIC_API_URL?.trim();\n    if (apiUrl && apiUrl !== \"\") {\n      // Se começa com https, usar ProductionStrategy\n      if (apiUrl.startsWith(\"https://\")) {\n        return new ProductionEnvironmentStrategy(apiUrl);\n      }\n      // Se começa com http, também usar ProductionStrategy (pode ser desenvolvimento)\n      if (apiUrl.startsWith(\"http://\")) {\n        return new ProductionEnvironmentStrategy(apiUrl);\n      }\n    }\n\n    // Prioridade 2: Verificar se há URL do Cloudflare Tunnel\n    const tunnelUrl = process.env.NEXT_PUBLIC_CLOUDFLARE_TUNNEL_URL?.trim();\n    if (tunnelUrl && tunnelUrl !== \"\") {\n      return new CloudflareTunnelStrategy(tunnelUrl);\n    }\n\n    // Prioridade 3: Se estiver em produção, usar Cloudflare Tunnel Strategy com URL padrão\n    if (isProduction) {\n      return new CloudflareTunnelStrategy(); // Usa https://talkfoodsoftwerk.net como padrão\n    }\n\n    // Prioridade 4: Verificar tipo de ambiente explícito\n    switch (envType.toLowerCase()) {\n      case EnvironmentType.CLOUDFLARE_TUNNEL:\n        return new CloudflareTunnelStrategy();\n      case EnvironmentType.PRODUCTION:\n        return new CloudflareTunnelStrategy(); // Usa https://talkfoodsoftwerk.net\n      case EnvironmentType.LOCAL:\n      case EnvironmentType.DEVELOPMENT:\n      default:\n        return new LocalEnvironmentStrategy();\n    }\n  }\n\n  static createFromType(type: EnvironmentType, customUrl?: string): IEnvironmentStrategy {\n    switch (type) {\n      case EnvironmentType.CLOUDFLARE_TUNNEL:\n        return new CloudflareTunnelStrategy(customUrl);\n      case EnvironmentType.PRODUCTION:\n        return new ProductionEnvironmentStrategy(customUrl);\n      case EnvironmentType.LOCAL:\n      case EnvironmentType.DEVELOPMENT:\n      default:\n        return new LocalEnvironmentStrategy();\n    }\n  }\n}\n\n/**\n * Singleton para acesso global à configuração de ambiente\n */\nclass EnvironmentConfigManager {\n  private static instance: EnvironmentConfigManager;\n  private strategy: IEnvironmentStrategy;\n\n  private constructor() {\n    try {\n      this.strategy = EnvironmentStrategyFactory.create();\n    } catch (error) {\n      // Fallback para CloudflareTunnelStrategy em caso de erro\n      console.error(\"Erro ao criar estratégia de ambiente, usando fallback:\", error);\n      this.strategy = new CloudflareTunnelStrategy();\n    }\n  }\n\n  static getInstance(): EnvironmentConfigManager {\n    if (!EnvironmentConfigManager.instance) {\n      EnvironmentConfigManager.instance = new EnvironmentConfigManager();\n    }\n    return EnvironmentConfigManager.instance;\n  }\n\n  getStrategy(): IEnvironmentStrategy {\n    return this.strategy;\n  }\n\n  setStrategy(strategy: IEnvironmentStrategy): void {\n    this.strategy = strategy;\n  }\n\n  getConfig(): EnvironmentConfig {\n    try {\n      return this.strategy.getConfig();\n    } catch (error) {\n      // Fallback seguro\n      console.error(\"Erro ao obter configuração, usando fallback:\", error);\n      return new CloudflareTunnelStrategy().getConfig();\n    }\n  }\n\n  getApiBaseUrl(): string {\n    try {\n      const url = this.strategy.getApiBaseUrl();\n      // Garantir que sempre retorna uma URL válida\n      if (!url || url.trim() === \"\") {\n        return \"https://talkfoodsoftwerk.net\";\n      }\n      return url;\n    } catch (error) {\n      // Fallback seguro\n      console.error(\"Erro ao obter URL da API, usando fallback:\", error);\n      return \"https://talkfoodsoftwerk.net\";\n    }\n  }\n}\n\n// Inicialização segura do singleton\nexport const environmentConfig = EnvironmentConfigManager.getInstance();\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 227, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Rafael%20Machado/Downloads/Frontend/src/core/http/http-client-factory.ts"],"sourcesContent":["/**\r\n * Factory Pattern para criar diferentes tipos de clientes HTTP\r\n * Implementa DRY e Strategy Pattern para diferentes estratégias de requisição\r\n */\r\n\r\nimport { environmentConfig } from \"../config/environment-strategy\";\r\n\r\nexport interface IHttpClient {\r\n  request<T>(endpoint: string, options?: HttpRequestOptions): Promise<T>;\r\n  get<T>(endpoint: string, options?: HttpRequestOptions): Promise<T>;\r\n  post<T>(endpoint: string, data?: unknown, options?: HttpRequestOptions): Promise<T>;\r\n  put<T>(endpoint: string, data?: unknown, options?: HttpRequestOptions): Promise<T>;\r\n  delete<T>(endpoint: string, options?: HttpRequestOptions): Promise<T>;\r\n}\r\n\r\nexport interface HttpRequestOptions extends RequestInit {\r\n  token?: string;\r\n  silent404?: boolean;\r\n  skipAuth?: boolean;\r\n}\r\n\r\n/**\r\n * Cliente HTTP base abstrato\r\n */\r\nabstract class BaseHttpClient implements IHttpClient {\r\n  protected abstract buildUrl(endpoint: string): string;\r\n  protected abstract buildHeaders(options: HttpRequestOptions): HeadersInit;\r\n\r\n  async request<T>(endpoint: string, options: HttpRequestOptions = {}): Promise<T> {\r\n    const url = this.buildUrl(endpoint);\r\n    const headers = this.buildHeaders(options);\r\n\r\n    return this.executeRequest<T>(url, { ...options, headers });\r\n  }\r\n\r\n  async get<T>(endpoint: string, options: HttpRequestOptions = {}): Promise<T> {\r\n    return this.request<T>(endpoint, { ...options, method: \"GET\" });\r\n  }\r\n\r\n  async post<T>(endpoint: string, data?: unknown, options: HttpRequestOptions = {}): Promise<T> {\r\n    return this.request<T>(endpoint, {\r\n      ...options,\r\n      method: \"POST\",\r\n      body: this.serializeBody(data),\r\n    });\r\n  }\r\n\r\n  async put<T>(endpoint: string, data?: unknown, options: HttpRequestOptions = {}): Promise<T> {\r\n    return this.request<T>(endpoint, {\r\n      ...options,\r\n      method: \"PUT\",\r\n      body: this.serializeBody(data),\r\n    });\r\n  }\r\n\r\n  async delete<T>(endpoint: string, options: HttpRequestOptions = {}): Promise<T> {\r\n    return this.request<T>(endpoint, { ...options, method: \"DELETE\" });\r\n  }\r\n\r\n  protected serializeBody(data: unknown): string | FormData | undefined {\r\n    if (!data) return undefined;\r\n    if (data instanceof FormData) return data;\r\n    return JSON.stringify(data);\r\n  }\r\n\r\n  protected async executeRequest<T>(\r\n    url: string,\r\n    options: HttpRequestOptions & { headers: HeadersInit }\r\n  ): Promise<T> {\r\n    const { silent404, ...fetchOptions } = options;\r\n\r\n    this.logRequest(url, fetchOptions);\r\n\r\n    try {\r\n      const response = await fetch(url, fetchOptions);\r\n\r\n      if (!response.ok) {\r\n        if (response.status === 404 && silent404) {\r\n          return null as T;\r\n        }\r\n        throw await this.createError(response);\r\n      }\r\n\r\n      return await this.parseResponse<T>(response);\r\n    } catch (error) {\r\n      throw this.handleRequestError(error, url);\r\n    }\r\n  }\r\n\r\n  protected async parseResponse<T>(response: Response): Promise<T> {\r\n    const contentType = response.headers.get(\"content-type\");\r\n    const text = await response.text();\r\n\r\n    if (!text || text.trim() === \"\") {\r\n      return null as T;\r\n    }\r\n\r\n    if (contentType?.includes(\"application/json\")) {\r\n      try {\r\n        return JSON.parse(text) as T;\r\n      } catch {\r\n        return null as T;\r\n      }\r\n    }\r\n\r\n    try {\r\n      return JSON.parse(text) as T;\r\n    } catch {\r\n      return null as T;\r\n    }\r\n  }\r\n\r\n  protected async createError(response: Response): Promise<Error> {\r\n    let errorMessage = `HTTP Error: ${response.status}`;\r\n\r\n    try {\r\n      const text = await response.text();\r\n      if (text) {\r\n        try {\r\n          const error = JSON.parse(text);\r\n          errorMessage = error.error || error.message || errorMessage;\r\n        } catch {\r\n          errorMessage = text || errorMessage;\r\n        }\r\n      }\r\n    } catch {\r\n      // Usar mensagem padrão\r\n    }\r\n\r\n    return new Error(errorMessage);\r\n  }\r\n\r\n  protected handleRequestError(error: unknown, url: string): Error {\r\n    if (error instanceof Error) {\r\n      if (error.message.includes(\"fetch\") || error.message.includes(\"ECONNREFUSED\")) {\r\n        const config = environmentConfig.getConfig();\r\n        return new Error(\r\n          `Não foi possível conectar ao servidor em ${config.baseUrl}. ` +\r\n          `Verifique se o backend está rodando e acessível.`\r\n        );\r\n      }\r\n      return error;\r\n    }\r\n\r\n    return new Error(`Erro desconhecido ao fazer requisição para ${url}`);\r\n  }\r\n\r\n  protected logRequest(url: string, options: RequestInit): void {\r\n    if (process.env.NODE_ENV === \"development\") {\r\n      console.log(`[HTTP] ${options.method || \"GET\"} ${url}`);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Cliente HTTP padrão com autenticação\r\n */\r\nexport class AuthenticatedHttpClient extends BaseHttpClient {\r\n  protected buildUrl(endpoint: string): string {\r\n    const baseUrl = environmentConfig.getApiBaseUrl();\r\n    const cleanBaseUrl = baseUrl.endsWith(\"/\") ? baseUrl.slice(0, -1) : baseUrl;\r\n    const cleanEndpoint = endpoint.startsWith(\"/\") ? endpoint : `/${endpoint}`;\r\n    return `${cleanBaseUrl}${cleanEndpoint}`;\r\n  }\r\n\r\n  protected buildHeaders(options: HttpRequestOptions): HeadersInit {\r\n    const headers: Record<string, string> = {\r\n      ...(options.headers as Record<string, string>),\r\n    };\r\n\r\n    if (options.token && !options.skipAuth) {\r\n      headers[\"Authorization\"] = `Bearer ${options.token}`;\r\n    }\r\n\r\n    if (!(options.body instanceof FormData)) {\r\n      headers[\"Content-Type\"] = \"application/json\";\r\n    }\r\n\r\n    return headers;\r\n  }\r\n}\r\n\r\n/**\r\n * Cliente HTTP público (sem autenticação)\r\n */\r\nexport class PublicHttpClient extends BaseHttpClient {\r\n  protected buildUrl(endpoint: string): string {\r\n    const baseUrl = environmentConfig.getApiBaseUrl();\r\n    const cleanBaseUrl = baseUrl.endsWith(\"/\") ? baseUrl.slice(0, -1) : baseUrl;\r\n    const cleanEndpoint = endpoint.startsWith(\"/\") ? endpoint : `/${endpoint}`;\r\n    return `${cleanBaseUrl}${cleanEndpoint}`;\r\n  }\r\n\r\n  protected buildHeaders(options: HttpRequestOptions): HeadersInit {\r\n    const headers: Record<string, string> = {\r\n      ...(options.headers as Record<string, string>),\r\n    };\r\n\r\n    if (!(options.body instanceof FormData)) {\r\n      headers[\"Content-Type\"] = \"application/json\";\r\n    }\r\n\r\n    return headers;\r\n  }\r\n}\r\n\r\n/**\r\n * Factory para criar clientes HTTP\r\n */\r\nexport class HttpClientFactory {\r\n  private static authenticatedClient: IHttpClient;\r\n  private static publicClient: IHttpClient;\r\n\r\n  static getAuthenticatedClient(): IHttpClient {\r\n    if (!this.authenticatedClient) {\r\n      this.authenticatedClient = new AuthenticatedHttpClient();\r\n    }\r\n    return this.authenticatedClient;\r\n  }\r\n\r\n  static getPublicClient(): IHttpClient {\r\n    if (!this.publicClient) {\r\n      this.publicClient = new PublicHttpClient();\r\n    }\r\n    return this.publicClient;\r\n  }\r\n\r\n  static reset(): void {\r\n    this.authenticatedClient = new AuthenticatedHttpClient();\r\n    this.publicClient = new PublicHttpClient();\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 411, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Rafael%20Machado/Downloads/Frontend/src/core/http/api-adapter.ts"],"sourcesContent":["/**\r\n * Adapter Pattern para compatibilidade com código legado\r\n * Mantém a interface antiga enquanto usa o novo sistema internamente\r\n */\r\n\r\nimport { HttpClientFactory, HttpRequestOptions } from \"./http-client-factory\";\r\nimport { IHttpClient } from \"./http-client-factory\";\r\n\r\n/**\r\n * Adapter que mantém compatibilidade com a API antiga\r\n * Implementa DRY ao centralizar toda lógica de requisição\r\n */\r\nexport class ApiAdapter {\r\n  private client: IHttpClient;\r\n\r\n  constructor(client?: IHttpClient) {\r\n    this.client = client || HttpClientFactory.getAuthenticatedClient();\r\n  }\r\n\r\n  /**\r\n   * Método principal que substitui o apiClient antigo\r\n   * Mantém a mesma interface para facilitar migração\r\n   */\r\n  async request<T>(endpoint: string, options: HttpRequestOptions = {}): Promise<T> {\r\n    const method = options.method || \"GET\";\r\n\r\n    switch (method.toUpperCase()) {\r\n      case \"GET\":\r\n        return this.client.get<T>(endpoint, options);\r\n      case \"POST\":\r\n        return this.client.post<T>(endpoint, this.parseBody(options.body), options);\r\n      case \"PUT\":\r\n        return this.client.put<T>(endpoint, this.parseBody(options.body), options);\r\n      case \"DELETE\":\r\n        return this.client.delete<T>(endpoint, options);\r\n      default:\r\n        return this.client.request<T>(endpoint, options);\r\n    }\r\n  }\r\n\r\n  private parseBody(body: unknown): unknown {\r\n    if (typeof body === \"string\") {\r\n      try {\r\n        return JSON.parse(body);\r\n      } catch {\r\n        return body;\r\n      }\r\n    }\r\n    return body;\r\n  }\r\n\r\n  /**\r\n   * Métodos auxiliares para facilitar uso\r\n   */\r\n  async get<T>(endpoint: string, options?: HttpRequestOptions): Promise<T> {\r\n    return this.client.get<T>(endpoint, options);\r\n  }\r\n\r\n  async post<T>(endpoint: string, data?: unknown, options?: HttpRequestOptions): Promise<T> {\r\n    return this.client.post<T>(endpoint, data, options);\r\n  }\r\n\r\n  async put<T>(endpoint: string, data?: unknown, options?: HttpRequestOptions): Promise<T> {\r\n    return this.client.put<T>(endpoint, data, options);\r\n  }\r\n\r\n  async delete<T>(endpoint: string, options?: HttpRequestOptions): Promise<T> {\r\n    return this.client.delete<T>(endpoint, options);\r\n  }\r\n}\r\n\r\n/**\r\n * Instância singleton do adapter\r\n */\r\nlet apiAdapterInstance: ApiAdapter | null = null;\r\n\r\nexport function getApiAdapter(): ApiAdapter {\r\n  if (!apiAdapterInstance) {\r\n    apiAdapterInstance = new ApiAdapter();\r\n  }\r\n  return apiAdapterInstance;\r\n}\r\n\r\n/**\r\n * Função de compatibilidade que mantém a interface antiga\r\n * @deprecated Use getApiAdapter() diretamente para melhor tipagem\r\n */\r\nexport async function apiClient<T>(\r\n  endpoint: string,\r\n  options: HttpRequestOptions = {}\r\n): Promise<T> {\r\n  const adapter = getApiAdapter();\r\n  return adapter.request<T>(endpoint, options);\r\n}\r\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;AAED;;AAOO,MAAM;IACH,OAAoB;IAE5B,YAAY,MAAoB,CAAE;QAChC,IAAI,CAAC,MAAM,GAAG,UAAU,qKAAiB,CAAC,sBAAsB;IAClE;IAEA;;;GAGC,GACD,MAAM,QAAW,QAAgB,EAAE,UAA8B,CAAC,CAAC,EAAc;QAC/E,MAAM,SAAS,QAAQ,MAAM,IAAI;QAEjC,OAAQ,OAAO,WAAW;YACxB,KAAK;gBACH,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAI,UAAU;YACtC,KAAK;gBACH,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAI,UAAU,IAAI,CAAC,SAAS,CAAC,QAAQ,IAAI,GAAG;YACrE,KAAK;gBACH,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAI,UAAU,IAAI,CAAC,SAAS,CAAC,QAAQ,IAAI,GAAG;YACpE,KAAK;gBACH,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAI,UAAU;YACzC;gBACE,OAAO,IAAI,CAAC,MAAM,CAAC,OAAO,CAAI,UAAU;QAC5C;IACF;IAEQ,UAAU,IAAa,EAAW;QACxC,IAAI,OAAO,SAAS,UAAU;YAC5B,IAAI;gBACF,OAAO,KAAK,KAAK,CAAC;YACpB,EAAE,OAAM;gBACN,OAAO;YACT;QACF;QACA,OAAO;IACT;IAEA;;GAEC,GACD,MAAM,IAAO,QAAgB,EAAE,OAA4B,EAAc;QACvE,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAI,UAAU;IACtC;IAEA,MAAM,KAAQ,QAAgB,EAAE,IAAc,EAAE,OAA4B,EAAc;QACxF,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAI,UAAU,MAAM;IAC7C;IAEA,MAAM,IAAO,QAAgB,EAAE,IAAc,EAAE,OAA4B,EAAc;QACvF,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAI,UAAU,MAAM;IAC5C;IAEA,MAAM,OAAU,QAAgB,EAAE,OAA4B,EAAc;QAC1E,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAI,UAAU;IACzC;AACF;AAEA;;CAEC,GACD,IAAI,qBAAwC;AAErC,SAAS;IACd,IAAI,CAAC,oBAAoB;QACvB,qBAAqB,IAAI;IAC3B;IACA,OAAO;AACT;AAMO,eAAe,UACpB,QAAgB,EAChB,UAA8B,CAAC,CAAC;IAEhC,MAAM,UAAU;IAChB,OAAO,QAAQ,OAAO,CAAI,UAAU;AACtC"}},
    {"offset": {"line": 489, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Rafael%20Machado/Downloads/Frontend/src/lib/api.ts"],"sourcesContent":["/**\n * API Client refatorado usando Strategy Pattern e Factory Pattern\n * Mantém compatibilidade com código legado através do Adapter Pattern\n */\n\nimport { apiClient as newApiClient, getApiAdapter } from \"@/core/http/api-adapter\";\nimport { environmentConfig } from \"@/core/config/environment-strategy\";\n\n// Re-exportar getApiAdapter para compatibilidade\nexport { getApiAdapter } from \"@/core/http/api-adapter\";\n\n/**\n * @deprecated Use environmentConfig.getApiBaseUrl() diretamente\n * Mantido para compatibilidade com código legado\n */\nexport function getApiUrl(): string {\n  return environmentConfig.getApiBaseUrl();\n}\n\n/**\n * Interface de compatibilidade mantida para facilitar migração\n * @deprecated Use HttpRequestOptions de @/core/http/http-client-factory\n */\nexport interface FetchOptions extends RequestInit {\n  token?: string;\n  cache?: \"force-cache\" | \"no-store\";\n  next?: {\n    revalidate?: false | 0 | number;\n    tags?: string[];\n  };\n  silent404?: boolean;\n}\n\n/**\n * Função de compatibilidade que usa o novo sistema internamente\n * Mantém a mesma interface para não quebrar código existente\n * @deprecated Use getApiAdapter() diretamente para melhor performance e tipagem\n */\nexport async function apiClient<T>(\n  endpoint: string,\n  options: FetchOptions = {}\n): Promise<T> {\n  return newApiClient<T>(endpoint, options);\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;AAED;AACA;;;;AASO,SAAS;IACd,OAAO,qKAAiB,CAAC,aAAa;AACxC;AAqBO,eAAe,UACpB,QAAgB,EAChB,UAAwB,CAAC,CAAC;IAE1B,OAAO,IAAA,kJAAY,EAAI,UAAU;AACnC"}},
    {"offset": {"line": 513, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Rafael%20Machado/Downloads/Frontend/src/lib/auth.ts"],"sourcesContent":["import { apiClient } from \"@/lib/api\";\nimport { User } from \"@/lib/types\";\nimport { cookies } from \"next/headers\";\nimport { redirect } from \"next/navigation\";\n\nconst COOKIE_NAME = \"token_pizzaria\";\n\n/**\n * Normaliza o role do usuário (número ou string) para string uppercase\n * Suporta:\n * - Número: 1 = ADMIN, outros = STAFF\n * - String: \"admin\", \"Admin\", \"ADMIN\" → \"ADMIN\"\n * \n * @param role - Role do usuário (número ou string)\n * @returns Role normalizado como string uppercase\n */\nfunction normalizeRole(role: unknown): string {\n  // Se for número\n  if (typeof role === \"number\") {\n    return role === 1 ? \"ADMIN\" : \"STAFF\";\n  }\n\n  // Se for string, retornar em uppercase\n  if (typeof role === \"string\") {\n    return role.toUpperCase();\n  }\n\n  // Fallback seguro (nunca deve chegar aqui, mas garante que não quebra)\n  return \"STAFF\";\n}\n\nexport async function getToken(): Promise<string | undefined> {\n  const cookieStore = await cookies();\n  return cookieStore.get(COOKIE_NAME)?.value;\n}\n\nexport async function setToken(token: string) {\n  const cookieStore = await cookies();\n  cookieStore.set(COOKIE_NAME, token, {\n    httpOnly: true,\n    maxAge: 60 * 60 * 24 * 30,\n    path: \"/\",\n    sameSite: true,\n    secure: process.env.NODE_ENV === \"production\",\n  });\n}\n\nexport async function removeToken() {\n  const cookieStore = await cookies();\n  cookieStore.delete(COOKIE_NAME);\n}\n\nexport async function getUser(): Promise<User | null> {\n  try {\n    const token = await getToken();\n\n    if (!token) {\n      return null;\n    }\n\n    const user = await apiClient<User>(\"/api/auth/me\", {\n      token: token,\n    });\n\n    return user;\n  } catch (err) {\n    // console.log(err);\n    return null;\n  }\n}\n\nexport async function requiredAdmin(): Promise<User> {\n  const user = await getUser();\n\n  if (!user) {\n    redirect(\"/login\");\n  }\n\n  // Normalizar role para garantir compatibilidade com número ou string\n  const normalizedRole = normalizeRole(user.role);\n  if (normalizedRole !== \"ADMIN\") {\n    redirect(\"/access-denied\");\n  }\n\n  return user;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AAEA;AACA;AAAA;;;;AAEA,MAAM,cAAc;AAEpB;;;;;;;;CAQC,GACD,SAAS,cAAc,IAAa;IAClC,gBAAgB;IAChB,IAAI,OAAO,SAAS,UAAU;QAC5B,OAAO,SAAS,IAAI,UAAU;IAChC;IAEA,uCAAuC;IACvC,IAAI,OAAO,SAAS,UAAU;QAC5B,OAAO,KAAK,WAAW;IACzB;IAEA,uEAAuE;IACvE,OAAO;AACT;AAEO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,0IAAO;IACjC,OAAO,YAAY,GAAG,CAAC,cAAc;AACvC;AAEO,eAAe,SAAS,KAAa;IAC1C,MAAM,cAAc,MAAM,IAAA,0IAAO;IACjC,YAAY,GAAG,CAAC,aAAa,OAAO;QAClC,UAAU;QACV,QAAQ,KAAK,KAAK,KAAK;QACvB,MAAM;QACN,UAAU;QACV,QAAQ,oDAAyB;IACnC;AACF;AAEO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,0IAAO;IACjC,YAAY,MAAM,CAAC;AACrB;AAEO,eAAe;IACpB,IAAI;QACF,MAAM,QAAQ,MAAM;QAEpB,IAAI,CAAC,OAAO;YACV,OAAO;QACT;QAEA,MAAM,OAAO,MAAM,IAAA,8IAAS,EAAO,gBAAgB;YACjD,OAAO;QACT;QAEA,OAAO;IACT,EAAE,OAAO,KAAK;QACZ,oBAAoB;QACpB,OAAO;IACT;AACF;AAEO,eAAe;IACpB,MAAM,OAAO,MAAM;IAEnB,IAAI,CAAC,MAAM;QACT,IAAA,iMAAQ,EAAC;IACX;IAEA,qEAAqE;IACrE,MAAM,iBAAiB,cAAc,KAAK,IAAI;IAC9C,IAAI,mBAAmB,SAAS;QAC9B,IAAA,iMAAQ,EAAC;IACX;IAEA,OAAO;AACT"}},
    {"offset": {"line": 602, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Rafael%20Machado/Downloads/Frontend/src/actions/auth.ts"],"sourcesContent":["\"use server\";\n\nimport { apiClient } from \"@/lib/api\";\nimport { removeToken, setToken } from \"@/lib/auth\";\nimport { AuthResponse, User } from \"@/lib/types\";\nimport { redirect } from \"next/navigation\";\n\nexport async function registerAction(\n  prevState: { success: boolean; error: string; redirectTo?: string } | null,\n  formData: FormData\n) {\n  try {\n    const name = formData.get(\"name\") as string;\n    const email = formData.get(\"email\") as string;\n    const password = formData.get(\"password\") as string;\n\n    const data = {\n      name: name,\n      email: email,\n      password: password,\n    };\n\n    await apiClient<User>(\"/api/auth/users\", {\n      method: \"POST\",\n      body: JSON.stringify(data),\n    });\n\n    return { success: true, error: \"\", redirectTo: \"/login\" };\n  } catch (error) {\n    if (error instanceof Error) {\n      return { success: false, error: error.message };\n    }\n\n    return { success: false, error: \"Erro ao criar conta\" };\n  }\n}\n\nexport async function loginAction(\n  prevState: { success: boolean; error: string; redirectTo?: string } | null,\n  formData: FormData\n) {\n  try {\n    const email = formData.get(\"email\") as string;\n    const password = formData.get(\"password\") as string;\n\n    const data = {\n      email: email,\n      password: password,\n    };\n\n    const response = await apiClient<{ token: string; user: User }>(\"/api/auth/session\", {\n      method: \"POST\",\n      body: JSON.stringify(data),\n    });\n\n    await setToken(response.token);\n\n    return { success: true, error: \"\", redirectTo: \"/dashboard\" };\n  } catch (error) {\n    console.error(\"Erro no login:\", error);\n\n    if (error instanceof Error) {\n      // Mensagens de erro mais amigáveis\n      let errorMessage = error.message;\n      \n      if (errorMessage.includes(\"ECONNREFUSED\") || errorMessage.includes(\"fetch failed\")) {\n        errorMessage = \"Não foi possível conectar ao servidor. Verifique se o backend está rodando na porta 3333.\";\n      } else if (errorMessage.includes(\"401\") || errorMessage.includes(\"Unauthorized\")) {\n        errorMessage = \"Email ou senha incorretos.\";\n      } else if (errorMessage.includes(\"404\")) {\n        errorMessage = \"Serviço não encontrado. Verifique a URL da API.\";\n      }\n      \n      return {\n        success: false,\n        error: errorMessage,\n      };\n    }\n\n    return { success: false, error: \"Erro ao fazer o login. Tente novamente.\" };\n  }\n}\n\nexport async function logoutAction() {\n  await removeToken();\n  redirect(\"/login\");\n}\n"],"names":[],"mappings":";;;;;;;;;AAEA;AACA;AAEA;AAAA;;;;;;AAEO,eAAe,eACpB,SAA0E,EAC1E,QAAkB;IAElB,IAAI;QACF,MAAM,OAAO,SAAS,GAAG,CAAC;QAC1B,MAAM,QAAQ,SAAS,GAAG,CAAC;QAC3B,MAAM,WAAW,SAAS,GAAG,CAAC;QAE9B,MAAM,OAAO;YACX,MAAM;YACN,OAAO;YACP,UAAU;QACZ;QAEA,MAAM,IAAA,8IAAS,EAAO,mBAAmB;YACvC,QAAQ;YACR,MAAM,KAAK,SAAS,CAAC;QACvB;QAEA,OAAO;YAAE,SAAS;YAAM,OAAO;YAAI,YAAY;QAAS;IAC1D,EAAE,OAAO,OAAO;QACd,IAAI,iBAAiB,OAAO;YAC1B,OAAO;gBAAE,SAAS;gBAAO,OAAO,MAAM,OAAO;YAAC;QAChD;QAEA,OAAO;YAAE,SAAS;YAAO,OAAO;QAAsB;IACxD;AACF;AAEO,eAAe,YACpB,SAA0E,EAC1E,QAAkB;IAElB,IAAI;QACF,MAAM,QAAQ,SAAS,GAAG,CAAC;QAC3B,MAAM,WAAW,SAAS,GAAG,CAAC;QAE9B,MAAM,OAAO;YACX,OAAO;YACP,UAAU;QACZ;QAEA,MAAM,WAAW,MAAM,IAAA,8IAAS,EAAgC,qBAAqB;YACnF,QAAQ;YACR,MAAM,KAAK,SAAS,CAAC;QACvB;QAEA,MAAM,IAAA,8HAAQ,EAAC,SAAS,KAAK;QAE7B,OAAO;YAAE,SAAS;YAAM,OAAO;YAAI,YAAY;QAAa;IAC9D,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,kBAAkB;QAEhC,IAAI,iBAAiB,OAAO;YAC1B,mCAAmC;YACnC,IAAI,eAAe,MAAM,OAAO;YAEhC,IAAI,aAAa,QAAQ,CAAC,mBAAmB,aAAa,QAAQ,CAAC,iBAAiB;gBAClF,eAAe;YACjB,OAAO,IAAI,aAAa,QAAQ,CAAC,UAAU,aAAa,QAAQ,CAAC,iBAAiB;gBAChF,eAAe;YACjB,OAAO,IAAI,aAAa,QAAQ,CAAC,QAAQ;gBACvC,eAAe;YACjB;YAEA,OAAO;gBACL,SAAS;gBACT,OAAO;YACT;QACF;QAEA,OAAO;YAAE,SAAS;YAAO,OAAO;QAA0C;IAC5E;AACF;AAEO,eAAe;IACpB,MAAM,IAAA,iIAAW;IACjB,IAAA,iMAAQ,EAAC;AACX;;;IA/EsB;IA8BA;IA8CA;;AA5EA,+OAAA;AA8BA,+OAAA;AA8CA,+OAAA"}},
    {"offset": {"line": 710, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Rafael%20Machado/Downloads/Frontend/.next-internal/server/app/login/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {loginAction as '60d33d8ed334dbd5a58748aad245d58c63a538d922'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA"}}]
}